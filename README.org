#+TITLE: Emacs Configuration
#+AUTHOR: Yauhen Artsiukhou
#+TOC: true
#+PROPERTY: header-args :tangle yes

This file explains my emacs configuration: https://github.com/jsirex/emacs.d

My previous emacs configuration was based on wonderful ~Steves~' configuration:

- https://github.com/purcell/emacs.d

* System Requirements

  I like to getting new things as soon as possible, so don't hesitate to use latest versions:

  - ~Debian GNU/Linux Testing~
  - ~emacs-snapshot~ (/currently >= 27.0/)

  There are lots of stuff required to emacs function properly: compilers, tools, cli, fonts, etc...

  For that purpose I added ~install.sh~ which is safe to run multiple times.

  #+BEGIN_QUOTE
  Script must be run as regular user, but it *requires sudo*!
  #+END_QUOTE

  Here is example of installation procedure:

  #+BEGIN_SRC shell-script
    cd ~

    git clone github.com:<your-user>/emacs.d ~/.emacs.d
    cd ~/.emacs.d

    git remote add upstream https://github.com/jsirex/emacs.d.git

    # initial installation of emacs binaries
    # if required, you can override sudo command by:
    # SUDO="sudo -i -A"
    ./install.sh

    # Byte compile files
    make

    # run
    emacs
  #+END_SRC

  That's it!

* Forking | Using | Contributing

  I didn't think too much about customization for now, not sure it is necessary.
  I hope ~git~ is enough for straight fork:

  1. Fork this repo on github
  2. Clone it to your home
  3. Customize configuration - it is strongly recommended to use one commit per logical change
  4. Add this repo as ~upstream~ repository
  5. Pull changes periodically
  6. If you want to share your fix or improvement
     1. Start new branch at ~upstream/master~
     2. Make changes or cherry-pick commits
     3. Create pull request

* Configuration principles

  I think that maintain an universal emacs configuration which works brilliant both on Linux, Mac and Windows is too hard.
  That's why this particular configuration has strong focus on ~Debian GNU/Linux~ in GUI mode.
  There is good chance that it will work under any ~Linux~.

  I *didn't* test it in a console *terminal* mode as it is rare case for me.

  1. Keep 3rd party packages as minimum as possible. Prefer stock functions.
  2. Try to ~defer~ loading every package until it actually requied.
  3. Use ~package-user-dir~ based on your emacs version. This prevents bytecode incompatibility.

* Personal Information

  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Yauhen Artsiukhou"
	  user-mail-address "jsirex@gmail.com")
  #+END_SRC

* Emacs Initialization
** Compilation

  There is two possible ways to start emacs: from compiled files and not.
  Compiled version loads faster and prefered in day to day work.
  But if you want modify emacs itself (this file) new changes will take effect after compilation.
  So it is better idea to clean compiled files with ~make clean~, work under emacs configuration.
  When ready - do a final compile: ~make~.

** Garbage Collector

   Increase Garbage Collector to a very high number improves startup time.
   Reset its' value back ~after-init~ to prevent big ~gc~ pauses.

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (setq gc-cons-threshold 268435456 ; 256 MB
         gc-cons-percentage 0.6))

     (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold 16777216 ; 16 MB
						 gc-cons-percentage 0.1)))
   #+END_SRC

** Recursion Limits

   It is bad idea to set these values too high, but sometims I'm reaching defaults, so increase them.

   #+BEGIN_SRC emacs-lisp
     (setq max-lisp-eval-depth 50000)
     (setq max-specpdl-size 10000)
   #+END_SRC

** Byte Compiler

   Disable certain byte compiler warnings to cut down on the noise.

   #+BEGIN_SRC emacs-lisp
     (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
   #+END_SRC

** Package Manager

   Manage packages and its' configuration with ~use-package~.
   Consider https://github.com/jwiegley/use-package for additional information.

   Configure ~use-package~:

   - Ensure automatic install of requied package
   - Defer package loading until explicit call improves startup time

   You can turn package statistics on when compile: use ~use-package-report~ to show report

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (setq use-package-always-ensure t
         use-package-always-defer t
         use-package-compute-statistics nil
         use-package-verbose t))
   #+END_SRC

   We’re going to set the ~load-path~ ourselves avoiding call to ~package-initilize~ (for performance reasons).
   So we need to set ~package--init-file-ensured~ to tell ~package.el~ to not automatically call it on our behalf.

   Additionally we’re unsetting ~package-enable-at-startup~ so that packages will not automatically be loaded for us since ~use-package~ will be handling that.

   We're also installing packages into separate dirs for each emacs version. This prevent bytecode incompatibility.

   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (setq package-user-dir (expand-file-name (format "elpa-%s.%s" emacs-major-version emacs-minor-version) user-emacs-directory)
         package--init-file-ensured t
         package-enable-at-startup nil
         load-prefer-newer noninteractive)

       (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))

       (unless (file-directory-p package-user-dir)
	 (mkdir package-user-dir))
       (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))
   #+END_SRC

   Next we are going to require ~package.el~ and add our additional package archives, ‘melpa’ and ‘org’. Afterwards we need to initialize our packages and then ensure that ~use-package~ is installed, which we promptly install if it’s missing. Finally we load ~use-package~ and tell it to always install any missing packages.

   Note that this entire block is wrapped in ~eval-when-compile~. The effect of this is to perform all of the package initialization during compilation so that when byte compiled, all of this time consuming code is skipped. This can be done because the result of byte compiling ~use-package~ statements results in the macro being fully expanded at which point ~use-package~ isn’t actually required any longer.

   Since the code is automatically compiled during runtime, if the configuration hasn’t already been previously compiled manually then all of the package initialization will still take place at startup.

   #+BEGIN_SRC emacs-lisp
     (eval-when-compile
       (require 'package)

       ;; (add-to-list 'package-archives '("gnu"   . "https://elpa.gnu.org/packages/") t)
       (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
       (add-to-list 'package-archives '("org"   . "https://orgmode.org/elpa/") t)

       (package-initialize)
       (unless (package-installed-p 'use-package)
	 (package-refresh-contents)
	 (package-install 'use-package))
       (require 'use-package))
   #+END_SRC

   We also install ~use-package~ dependencies:
   - ~diminish~ package to hide modes from mode line
   - ~bind-key~ byte-code macro ~use-package~ doesn't include it.

   #+BEGIN_SRC emacs-lisp
     ;; requires by use-package
     (use-package diminish :demand t)

     ;; requires bind-key from use-package
     (require 'use-package-bind-key)
   #+END_SRC

* Core Settings

  Emacs has large number of default settings which can be customized. Let describe them in this section.
  All package specific settings are stored within ~use-package~ settings.

** UTF-8 Charset

   #+BEGIN_SRC emacs-lisp
     (set-default-coding-systems 'utf-8)
     (set-language-environment 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)

     (setq-default buffer-file-coding-system 'utf-8)
   #+END_SRC

   Disable bidirectional text for little performance.

   #+BEGIN_SRC emacs-lisp
     (setq-default bidi-display-reordering nil)
   #+END_SRC

** File Backups

   Disable file backups and auto saves.

   #+BEGIN_SRC emacs-lisp
     (setq-default
      auto-save-default nil
      auto-save-list-file-name (expand-file-name ".cache/autosave" user-emacs-directory)
      create-lockfiles nil
      make-backup-files nil)
   #+END_SRC

** Emacs Custom File

   Emacs stores custom settings in the ~custom-file~ file.
   Prefer customizations through the source code so override it to ~/dev/null~.

   #+BEGIN_SRC emacs-lisp
     ;; in case any code uses custom file do it when compile too
     (eval-and-compile
       (setq custom-file "/dev/null"))
   #+END_SRC

** Save Desktop

   This saves emacs at exit and load on next start.

   #+BEGIN_SRC emacs-lisp
     ;; Save desktop
     (setq desktop-path (list (expand-file-name ".cache/" user-emacs-directory))
	   desktop-dirname (expand-file-name ".cache/" user-emacs-directory)
	   desktop-base-file-name "emacs-desktop"
	   desktop-auto-save-timeout 600)

     (desktop-save-mode 1)
   #+END_SRC

** History

   Memorize history between startups.

   #+BEGIN_SRC emacs-lisp
     (setq
      history-length 1000
      save-place-file (expand-file-name ".cache/places" user-emacs-directory)
      savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
      savehist-autosave-interval nil ; save on kill only
      savehist-file (expand-file-name ".cache/history" user-emacs-directory)
      savehist-save-minibuffer-history t)

     (savehist-mode 1)
     (save-place-mode 1)
   #+END_SRC

   Recent file location:
   #+BEGIN_SRC emacs-lisp
     (setq recentf-save-file (expand-file-name ".cache/recentf" user-emacs-directory))
   #+END_SRC

** Server

   https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html:
   #+BEGIN_QUOTE
   Various programs can invoke your choice of editor to edit a particular piece of text. For instance, version control programs invoke an editor to enter version control logs (see Version Control), and the Unix mail utility invokes an editor to enter a message to send. By convention, your choice of editor is specified by the environment variable EDITOR. If you set EDITOR to ‘emacs’, Emacs would be invoked, but in an inconvenient way—by starting a new Emacs process. This is inconvenient because the new Emacs process doesn't share buffers, a command history, or other kinds of information with any existing Emacs process.

   You can solve this problem by setting up Emacs as an edit server, so that it “listens” for external edit requests and acts accordingly.
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp :tangle no
     (unless (server-running-p) (server-start))
   #+END_SRC

* Editor
** Bell Functions

   Disable bell function and visible bell.

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function #'ignore
	   visible-bell nil)
   #+END_SRC

** Whitespace and Lines

   This displays white spaces, tabs with spaced mixed.
   Removed ~empty~ because of odd behavior.

   #+BEGIN_SRC emacs-lisp
     (setq-default
      require-final-newline t
      whitespace-action '(auto-cleanup warn-read-only)
      whitespace-style '(face empty trailing space-after-tab space-before-tab))

     (global-whitespace-mode)
   #+END_SRC

   By default use spaces instead of tabs:
   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil
                   tab-width 4)
   #+END_SRC

** Auto Revert Buffer

   When file changed on disk this automatically loads new version.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC

** Highlight Matching Parens

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode)
   #+END_SRC

** Fira Code Font

   I liked ~Fira Code~ font with ligatures: https://github.com/tonsky/FiraCode/.
   In emacs I have to use ~Fira Code Regular Symbol~ - patched font for display ligatures.

   This font bundled in emacs repo in ~fonts/firacode~ directory.
   ~install.sh~ installs ~Fira Code~ font package and copies patched font to ~~/.local/share/fonts~

   #+BEGIN_SRC emacs-lisp
     ;;; Fira Code: monospaced font with programming ligatures: https://github.com/tonsky/FiraCode

     (add-to-list 'default-frame-alist '(font . "Fira Code-10"))

     (defun fira-code-mode--make-alist (list)
       "Generate prettify-symbols alist from LIST."
       (let ((idx -1))
	 (mapcar
	  (lambda (s)
        (setq idx (1+ idx))
        (let* ((code (+ #Xe100 idx))
		   (width (string-width s))
		   (prefix ())
		   (suffix '(?\s (Br . Br)))
		   (n 1))
          (while (< n width)
		(setq prefix (append prefix '(?\s (Br . Bl))))
		(setq n (1+ n)))
          (cons s (append prefix suffix (list (decode-char 'ucs code))))))
	  list)))

     (defconst fira-code-mode--ligatures
       '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
	 "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
	 "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
	 "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
	 ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
	 "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
	 "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
	 "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
	 ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
	 "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
	 "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
	 "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
	 "x" ":" "+" "+" "*"))

     (defvar fira-code-mode--old-prettify-alist)

     (defun fira-code-mode--enable ()
       "Enable Fira Code ligatures in current buffer."
       (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
       (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
       (prettify-symbols-mode t))

     (defun fira-code-mode--disable ()
       "Disable Fira Code ligatures in current buffer."
       (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
       (prettify-symbols-mode -1))

     (define-minor-mode fira-code-mode
       "Fira Code ligatures minor mode"
       :lighter " FiraCode"
       (setq-local prettify-symbols-unprettify-at-point 'right-edge)
       (if fira-code-mode
	   (fira-code-mode--enable)
	 (fira-code-mode--disable)))

     (defun fira-code-mode--setup ()
       "Setup Fira Code Symbols"
       (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))

     (fira-code-mode--setup)
     (diminish 'fira-code-mode)

     ;; Enable ligatures in the following modes
     (add-hook 'prog-mode-hook 'fira-code-mode)
     (add-hook 'org-mode-hook 'fira-code-mode)
     (add-hook 'html-mode-hook 'fira-code-mode)
   #+END_SRC

   Make it possible to change font size wit ~C-M-=~ and ~C-M--~.

   #+BEGIN_SRC emacs-lisp
     ;; Scale text size with C-M-= and C-M--
     (use-package default-text-scale
       :commands (default-text-scale-increase default-text-scale-decrease default-text-scale-reset)
       :config
       (default-text-scale-mode 1))
   #+END_SRC

** Which Key

   This helps you to see which key binds for what. Consider: https://github.com/justbur/emacs-which-key

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :defer 1
       :diminish which-key-mode
       :config
       (setq which-key-popup-type 'side-window
         which-key-side-window-location '(right bottom)
         which-key-sort-order #'which-key-prefix-then-key-order)
       (which-key-mode))
   #+END_SRC

** Editor Config

   Editor config helps keep editor configuration in sync across different users and editors.
   Consider https://editorconfig.org/.

   This package also expected ~editorconfig~ system package to be installed.
   I added automatic installation to the ~install.sh~ script.

   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :defer 2
       :diminish
       :config
       (editorconfig-mode 1))
   #+END_SRC

** Text Manipulations

   Liked this behavior from ~Steves~' configuration:

   #+BEGIN_SRC emacs-lisp
     (defun sanityinc/newline-at-end-of-line ()
       "Move to end of line, enter a newline, and reindent."
       (interactive)
       (move-end-of-line 1)
       (newline-and-indent))

     (global-set-key (kbd "S-<return>") 'sanityinc/newline-at-end-of-line)
   #+END_SRC

   TODO: I need to investigate what exactly is ~mark~, but for now delete selected text when typing:

   #+BEGIN_SRC emacs-lisp
     (delete-selection-mode)
   #+END_SRC

   Zap up to char: delete from current up to char.

   #+BEGIN_SRC emacs-lisp
     (use-package avy-zap
       :bind (("M-z" . avy-zap-up-to-char-dwim)
          ("M-Z" . avy-zap-up-to-char-dwim)))
   #+END_SRC

** Electric Pair

   #+BEGIN_SRC emacs-lisp
     (use-package electric
       :ensure nil
       :hook (prog-mode . electric-pair-mode))
   #+END_SRC

** Sub Word

   Move cursor through CamelCase, snake_case through the each word.

   #+BEGIN_SRC emacs-lisp
     (use-package subword
       :ensure nil
       :diminish
       :hook (prog-mode . subword-mode))
   #+END_SRC

** Expand Region

   This expands region: press ~C-=~ and then ~=~ to expand, ~-~ to collapse and ~0~ to reset.

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :bind ("C-=" . er/expand-region))
   #+END_SRC

** Move and Duplicate Lines

   Move and duplicate lines up and down.

   #+BEGIN_SRC emacs-lisp
     (use-package move-dup
       :bind (("M-<up>" . md/move-lines-up)
              ("M-<down>" . md/move-lines-down)
              ("C-c C-d" . md/duplicate-down)
              ("C-c C-u" . md/duplicate-up)))
   #+END_SRC
** Multiple Cursors

   This adds multiple cursor. Consider: https://github.com/magnars/multiple-cursors.el

   - Select /pattern/ and press ~C-c m m~ to mark all text with same pattern
   - Press ~C-<~ or ~C->~ marks one more item with same pattern
   - Hide lines without cursors with ~C-'~
   - Hit ~RET~ to stop multiple cursors
   - ~phi-search~ adds search support into ~multiple cursors~
   - Select /pattern/ and press ~C-)~ to select required cursors

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :init
       (setq mc/list-file (expand-file-name ".cache/mc-lists.el" user-emacs-directory))
       :bind (("C-<" . mc/mark-previous-like-this)
          ("C->" . mc/mark-next-like-this)
          ("C-c m m" . mc/mark-all-dwim)
          ("C-c m s" . mc/skip-to-next-like-this)))

     (use-package phi-search
       :bind (:map mc/keymap
		   ("C-s" . phi-search)
		   ("C-r" . phi-search-backward)))

     ;; Mark cursors almost like avy
     (use-package ace-mc
       :bind (("C-)" . ace-mc-add-multiple-cursors)))
   #+END_SRC

** Symbol Overlay

   This is best feature I saw in term of manipulation text. It helps highlight same symbols, move between them, refactor them.

   #+BEGIN_SRC emacs-lisp
     (use-package symbol-overlay
       :diminish
       :bind (:map symbol-overlay-mode-map
		   ("M-i" . symbol-overlay-put)
		   ("M-n" . symbol-overlay-jump-next)
		   ("M-p" . symbol-overlay-jump-prev))
       :hook ((prog-mode html-mode yaml-mode conf-mode) . symbol-overlay-mode))
   #+END_SRC

** Completion

   Here is some stock completions tunnings.

   Try to indent line then complete at point:
   #+BEGIN_SRC emacs-lisp
     (setq tab-always-indent 'complete)
   #+END_SRC

   Make completion work on ~initials~ - complete ~lch~ to ~list-command-history~:
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'completion-styles 'initials t)
   #+END_SRC

** Compilation

   Bind ~recompile~ to handy ~F6~ button and scroll output
   #+BEGIN_SRC emacs-lisp
     (setq compilation-scroll-output t)

     (global-set-key [f6] 'recompile)
   #+END_SRC

** Text Scrolling

   Scroll text like in regular editor:
   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 101)
   #+END_SRC

** Rainbow Text

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :hook ((prog-mode) . rainbow-delimiters-mode))

     ;; TODO: turn off probably
     (use-package rainbow-identifiers
       :hook((shell-script-mode) . rainbow-identifiers-mode))
   #+END_SRC

** Hide Show

   Hides and Show code chunks. TODO: move customizations to language section.
   #+BEGIN_SRC emacs-lisp
     (use-package hideshow
       ;; TODO: doesn't work :diminish ""
       :hook (prog-mode . hs-minor-mode)
       :bind (:map hs-minor-mode-map
                   ("<f9>" . hs-toggle-hiding))
       :config
       (add-to-list 'hs-special-modes-alist
                    '(ruby-mode "class\\|module\\|def\\|if\\|unless\\|case\\|while\\|until\\|for\\|begin\\|do\\|{" "end\\|}" "#\\|=begin")))
   #+END_SRC

** Snippets

   Use yasnippet:
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :commands (snippet-mode yas-minor-mode)
       :hook (prog-mode . yas-minor-mode)
       :diminish ""
       :config
       (yas-reload-all))

     (use-package yasnippet-snippets
       :after yasnippet)
   #+END_SRC

** Tramp

   Basic settings for tramp mode:
   #+BEGIN_SRC emacs-lisp
     (setq tramp-persistency-file-name (expand-file-name ".cache/tramp" user-emacs-directory))
   #+END_SRC

** WGrep

   Writable grep buffer. This allows you to grep text in buffer and edit text in-place applying to corresponding files.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep :demand t
       :config
       (setq wgrep-auto-save-buffer t))

     (use-package wgrep-ag :demand t)
   #+END_SRC

* Frames

  When Emacs is started on a graphical display, e.g., on the X Window System, it occupies a graphical system-level display region.
  We call this a ~frame~, reserving the word “window” for the part of the frame used for displaying a buffer.
  Read more at: https://www.gnu.org/software/emacs/manual/html_node/emacs/Frames.html

** Suspend

   Don't suspend frame, unbind hot keys:

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-z") nil)
     (global-set-key (kbd "C-x C-z") nil)
   #+END_SRC

** Disable Mouse

   Use keyboard.

   #+BEGIN_SRC emacs-lisp
     (use-package disable-mouse
       :defer 5
       :init
       (setq disable-mouse-mode-global-lighter "")
       :config
       (global-disable-mouse-mode))

   #+END_SRC

** Theme

   I prefer this theme. You can switch this theme using ~color-theme-sanityinc-tomorrow-<blue|day|night|bright|eighties>~ command.

   #+BEGIN_SRC emacs-lisp
     (use-package color-theme-sanityinc-tomorrow
       :demand t
       :config
       (setq custom-safe-themes t) ; suppress theme validation. unsafe
       (color-theme-sanityinc-tomorrow-eighties))
   #+END_SRC

* Windows

** TODO Split Windows

   Improve ~split-window~ function by automatically change new buffer to another.

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun split-window-func-with-other-buffer (split-function)
       (lambda (&optional arg)
	 "Split this window and switch to the new window unless ARG is provided."
	 (interactive "P")
	 (funcall split-function)
	 (let ((target-window (next-window)))
	   (set-window-buffer target-window (other-buffer))
	   (unless arg
         (select-window target-window)))))

     (global-set-key (kbd "C-x 2") (split-window-func-with-other-buffer 'split-window-vertically))
     (global-set-key (kbd "C-x 3") (split-window-func-with-other-buffer 'split-window-horizontally))
   #+END_SRC

** Switch Windows

   Switch between windows with ~C-<arrow>~.

   #+BEGIN_SRC emacs-lisp
     (windmove-default-keybindings 'control)
   #+END_SRC

   Switch between windows using uniq key with ~C-x o <key>~.

   #+BEGIN_SRC emacs-lisp
     (use-package switch-window
       :bind ("C-x o" . switch-window)
       :config
       (setq switch-window-shortcut-style 'qwerty))
   #+END_SRC

** Manage Layout

   ~winner~ mode helps to navigate window layouts with ~C-c <left>~ and ~C-c <right>~.
   This helps, for example, to restore previous window layout.

   #+BEGIN_SRC emacs-lisp
     (winner-mode)
   #+END_SRC

   ~zoom~ package automatically adjusts windows sizes. This makes emacs to behave like a tiling manager.
   I use golden ratio settings.

   #+BEGIN_SRC emacs-lisp
     (use-package zoom
       :demand t
       :diminish
       :config
       (setq zoom-size '(0.618 . 0.618))
       (zoom-mode 1))

   #+END_SRC

** Dimmer

   ~dimmer~ highlights current active buffer by dimming the faces in the other buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package dimmer
       :config
       (setq dimmer-fraction 0.20)
       (dimmer-mode 1))
   #+END_SRC

** Full Frame Window

   This library package helps some buffers to maximize to full frame:
   #+BEGIN_SRC emacs-lisp
    (use-package fullframe :commands fullframe)
   #+END_SRC

* Buffers

** Unkillable Scratch

   #+BEGIN_SRC emacs-lisp
     (use-package unkillable-scratch
       :defer 5
       :config
       (unkillable-scratch 1))
   #+END_SRC

** Undo Tree

   Displays nice modification history tree and helps you interactively do ~undo~.

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :diminish undo-tree-mode
       :config
       (setq undo-tree-visualizer-diff t)
       (global-undo-tree-mode))
   #+END_SRC

** Navigation with avy

   Avy helps quickly navigate you through the buffers: https://github.com/abo-abo/avy

   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :bind (("C-;" . avy-goto-char-timer)
          ("C-'" . avy-goto-line)))
   #+END_SRC

** IBuffer

   ~IBuffer~ is an advanced replacement for BufferMenu, which lets you operate on buffers much in the same manner as Dired.
   The most important Ibuffer features are highlighting and various alternate layouts.

   #+BEGIN_SRC emacs-lisp
     (use-package ibuffer
       :ensure nil
       :bind ("C-x C-b" . ibuffer))

     (use-package ibuffer-vc
       :hook (ibuffer-mode . ibuffer-set-up-preferred-filters)
       :config
       (defun ibuffer-set-up-preferred-filters ()
	 (ibuffer-vc-set-filter-groups-by-vc-root)
	 (unless (eq ibuffer-sorting-mode 'filename/process)
	   (ibuffer-do-sort-by-filename/process))))
   #+END_SRC

** Colorized Compilation

   Many compilation tools have colorized output, let turn on it by default via custom hook:
   #+BEGIN_SRC emacs-lisp
     (use-package ansi-color :ensure nil
       :init
       (defun my/colorize-compilation-buffer ()
	 (ansi-color-apply-on-region compilation-filter-start (point-max)))
       :hook (compilation-filter . my/colorize-compilation-buffer))
   #+END_SRC

* Directories and Files
** Dired

   TODO: make stuff here
   #+BEGIN_SRC emacs-lisp
     (use-package dired :ensure nil
       :config
       (setq dired-dwim-target t
         dired-auto-revert-buffer t
         dired-recursive-deletes 'top))

     (use-package diredfl
       :hook (dired-mode . diredfl-mode))
   #+END_SRC

* Fly Make
** Fly Make Mode

  In recent emacs version ~flymake~ has been refactored and is worth to be considered.

  #+BEGIN_SRC emacs-lisp
    (add-hook 'prog-mode-hook 'flymake-mode-on)
  #+END_SRC

** Diagnostic At Point

   Show tooltip with diagnostics.

   #+BEGIN_SRC emacs-lisp
     (use-package flymake-diagnostic-at-point
       :after flymake
       :hook (flymake-mode . flymake-diagnostic-at-point-mode))
   #+END_SRC

* Company

  Modular in-buffer completion framework for Emacs: http://company-mode.github.io/

  #+BEGIN_SRC emacs-lisp
    ;; TODO: binding and defer
    (use-package company
      :defer 3
      :commands (company-mode company-indent-or-complete-common)
      :diminish
      :bind (:map company-active-map
		  ("C-n" . company-select-next)
		  ("C-p" . company-select-previous))
      :config
      (setq
       company-dabbrev-ignore-case t
       company-dabbrev-downcase nil
       company-dabbrev-other-buffers t
       company-tooltip-align-annotations t
       company-idle-delay 0
       company-echo-delay 0
       company-minimum-prefix-length 3
       company-tooltip-limit 20)
      (global-company-mode)
      (add-to-list company-backends 'company-yasnippet))

    ;; TODO: performance
    (use-package company-box
      :disabled t
      :diminish
      :hook (company-mode . company-box-mode))
  #+END_SRC

* Ivy | Counsel | Swiper

  - ~Ivy~, a generic completion mechanism for Emacs
  - ~Counsel~ - a collection of Ivy-enhanced versions of common Emacs commands
  - ~Swiper~ - an ~Ivy~-enhanced alternative to isearch

  Consider: https://github.com/abo-abo/swiper

** Ivy

  #+BEGIN_SRC emacs-lisp
    (use-package ivy
      :diminish
      ;; :bind (:map ivy-minibuffer-map
      ;;     ("C-'" . ivy-avy))
      :config
      (setq ivy-use-virtual-buffers t ; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’
        ivy-height 15 ; number of result lines to display
        ivy-initial-inputs-alist nil ; don't add ^ by default
        ivy-count-format "(%d/%d) " ; Show candidate index and total count
        ivy-re-builders-alist '((t   . ivy--regex-ignore-order)) ; allow input not in order

        projectile-completion-system 'ivy ; use ivy for projectile
        smex-completion-method 'ivy ;  use ivy for smex
        )

      (ivy-mode))
  #+END_SRC

** Counsel

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :diminish
       :bind (("M-x" . counsel-M-x)
          ("C-x C-r" . counsel-recentf)
          ("C-h v" . counsel-describe-variable)
          ("C-h f" . counsel-describe-function)))

     (use-package counsel-tramp
       :commands counsel-tramp)
   #+END_SRC

** Swiper

   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :bind (("C-s" . swiper)))
   #+END_SRC

** Smex

   Optimize search and recentf history

   #+BEGIN_SRC emacs-lisp
     (use-package smex
       :config
       (setq smex-save-file (expand-file-name ".cache/smex-items" user-emacs-directory)))
   #+END_SRC

* Project Management

** Projectile

   Projectile is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible).
   Consider: https://github.com/bbatsov/projectile

   #+BEGIN_SRC emacs-lisp
     (use-package projectile :demand t
       :bind-keymap ("C-c p" . projectile-command-map)
       :config
       (setq projectile-mode-line-prefix " P"
             projectile-cache-file (expand-file-name ".cache/projectile.cache" user-emacs-directory)
             projectile-known-projects-file (expand-file-name ".cache/projectile-bookmarks.eld" user-emacs-directory)))

     (use-package counsel-projectile :demand t
       :config (counsel-projectile-mode))
   #+END_SRC

** Treemacs

   TODO: Refactor this

   #+BEGIN_SRC emacs-lisp
     ;; TODO: configure treemacs better
     (use-package treemacs
       :bind ("<f8>" . treemacs)
       :config
       (setq treemacs-collapse-dirs              3
         treemacs-deferred-git-apply-delay   0.5
         treemacs-display-in-side-window     t
         treemacs-file-event-delay           5000
         treemacs-file-follow-delay          0.2
         treemacs-follow-after-init          t
         treemacs-follow-recenter-distance   0.1
         treemacs-git-command-pipe           ""
         treemacs-goto-tag-strategy          'refetch-index
         treemacs-indentation                2
         treemacs-indentation-string         " "
         treemacs-is-never-other-window      nil
         treemacs-max-git-entries            5000
         treemacs-no-png-images              nil
         treemacs-no-delete-other-windows    t
         treemacs-project-follow-cleanup     nil
         treemacs-persist-file               (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
         treemacs-recenter-after-file-follow nil
         treemacs-recenter-after-tag-follow  nil
         treemacs-show-cursor                nil
         treemacs-show-hidden-files          t
         treemacs-silent-filewatch           nil
         treemacs-silent-refresh             nil
         treemacs-sorting                    'alphabetic-desc
         treemacs-space-between-root-nodes   t
         treemacs-tag-follow-cleanup         t
         treemacs-tag-follow-delay           1.5
         treemacs-width                      30)

       (treemacs-follow-mode t)
       (treemacs-filewatch-mode t)
       (treemacs-fringe-indicator-mode t)
       (treemacs-git-mode 'deferred))

     (use-package treemacs-projectile
       :after (treemacs projectile))

     (use-package treemacs-icons-dired
       :hook (dired-mode . treemacs-icons-dired-mode))
   #+END_SRC
* Languages
** Shell Script

   Shell Script mode is embedded but we can enhance this mode by ~flymake~ and ~company~.

   ~flymake~ requires shellcheck installed. Consider: ~install.sh~
   TODO: Fix load
   #+BEGIN_SRC emacs-lisp
     (use-package flymake-shellcheck :demand t
       :hook (sh-mode . flymake-shellcheck-load))
   #+END_SRC

   Add ~company~ backend
   #+BEGIN_SRC emacs-lisp
     (use-package company-shell
       :after company
       :commands company-shell
       :config (add-to-list 'company-backends 'company-shell))
   #+END_SRC

   Make scripts automatically executable after save:
   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook
        'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC

** CSV

   #+BEGIN_SRC emacs-lisp
     (use-package csv-mode
       :defer t
       :mode "\\.json\\'"
       :config
       (setq csv-separators '("," ";" "|" " ")))
   #+END_SRC
** Groovy

   #+BEGIN_SRC emacs-lisp
     (use-package groovy-mode :defer t
       :mode ("\\.groovy\\'" "\\Jenkinsfile\\'"))

     (use-package groovy-imports
       :hook (groovy-mode . groovy-imports-scan-file))
   #+END_SRC
** Ruby

   #+BEGIN_SRC emacs-lisp
     (use-package enh-ruby-mode
       :hook ruby-mode
       :mode (("Gemfile\\'" . ruby-mode)
              ("Thorfile\\'" . ruby-mode)
              ("Guardfile\\'" . ruby-mode)
              ("Rakefile\\'" . ruby-mode)
              ("\\.rake\\'" . ruby-mode)
              ("\\.ru\\'" . ruby-mode)
              ("\\.gemspec\\'" . ruby-mode)
              ("\\.builder\\'" . ruby-mode)
              ("\\.god\\'" . ruby-mode)))
   #+END_SRC
** Rust

   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :commands rust-mode)



     (use-package racer :defer t)
     (use-package flymake-rust :defer t)

   #+END_SRC
** Lisp

   #+BEGIN_SRC emacs-lisp
     (use-package page-break-lines
       :diminish
       :hook (emacs-lisp-mode . page-break-lines-mode))
   #+END_SRC

** JSON

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode :mode "\\.json\\'")
     (use-package json-snatcher :after json-mode)
   #+END_SRC
** TOML

   TOML language support:
   #+BEGIN_SRC emacs-lisp
    (use-package toml-mode)
   #+END_SRC
** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :commands yaml-mode)
   #+END_SRC
** XML

   TODO: NXML Mode better:
   #+BEGIN_SRC emacs-lisp
     (use-package nxml-mode :ensure nil
       :commands nxml-mode
       :init
       (defalias 'xml-mode 'nxml-mode))
   #+END_SRC

** Markdown

   Requires ~multimarkdown~ binary (~libtext-markup-perl~ package) for exports. Provided by ~install.sh~
   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :mode (("\\.md\\'" . gfm-mode)
              ("\\.markdown\\'" . gfm-mode))
       :config
       (setq markdown-command "multimarkdown"))
   #+END_SRC

* Configuration Management and DevOps
** SystemD

   TODO: update this
   #+BEGIN_SRC emacs-lisp
     (use-package systemd)
   #+END_SRC
** Daemons

   Handy UI for managing system services:
   #+BEGIN_SRC emacs-lisp
     (use-package daemons
       :commands daemons)
   #+END_SRC

** Docker

   Manage docker containers with ~C-c d~:
   #+BEGIN_SRC emacs-lisp
     (use-package docker
       :bind ("C-c d" . docker)
       :custom (docker-image-run-arguments '("-i" "-t" "--rm")))
   #+END_SRC

   Tramp mode for docker:
   #+BEGIN_SRC emacs-lisp
     (use-package docker-tramp :defer t
       :after docker
       :config
       (setq docker-tramp-use-names t))
   #+END_SRC

   Editing ~Dockerfile~ and ~docker-compose.yml~:
   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode)
     (use-package docker-compose-mode)
   #+END_SRC

** Ansible

   #+BEGIN_SRC emacs-lisp
     (use-package ansible)
   #+END_SRC

   Company backedn for ansible:
   #+BEGIN_SRC emacs-lisp
     (use-package company-ansible)
   #+END_SRC

*** Molecule

    Molecule is a testing framework for ansible. This wrapper adds number of commands to use ~molecule~ directly from emacs.
    TODO: disabled for now
    #+BEGIN_SRC emacs-lisp :tangle no
      (use-package molecule :disabled t)
    #+END_SRC

** Chef

** Terraform

   #+BEGIN_SRC emacs-lisp
     (use-package terraform-mode
       :mode "\\.tf\\'"
       :hook (terraform-mode . terraform-format-on-save-mode))

     (use-package company-terraform
       :hook (terraform-mode . company-terraform-init))
   #+END_SRC

* Org Mode

** Settings

   #+BEGIN_SRC emacs-lisp
     (setq org-special-ctrl-a/e 't
	   org-src-tab-acts-natively t)
   #+END_SRC

** Org Completion

   Add ~completion~ to ~company~ via ~pcomplete~

   #+BEGIN_SRC emacs-lisp
     (defun add-pcomplete-to-capf ()
       (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
     (add-hook 'org-mode-hook #'add-pcomplete-to-capf)
   #+END_SRC

** Export
*** htmlize

    Helps convert buffer to an html:
    TODO: better load, should it be in org?
    #+BEGIN_SRC emacs-lisp
      (use-package htmlize :defer 5)
    #+END_SRC

*** Twitter Boostrap HTML Export

    #+BEGIN_SRC emacs-lisp
      (use-package ox-twbs
	:commands org-twbs-export-to-html)
    #+END_SRC

* Version Control (git)

** Magit

   Gold standard of implementation things in emacs - ~magit~ - git manager.
   Consider: https://github.com/magit/magit

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind ("C-x g" . magit-status)
       :config
       (setq magit-completing-read-function 'ivy-completing-read
         magit-display-buffer-function 'magit-display-buffer-fullframe-status-topleft-v1))

     (use-package magit-todos
       :hook (magit-status-mode . magit-todos-mode))
   #+END_SRC

** Magithub

   Work with github in magit:
   #+BEGIN_SRC emacs-lisp
     (use-package magithub :after magit)
   #+END_SRC

** Git Lab

   #+BEGIN_SRC emacs-lisp
     ;; TODO: slows load up to 0.25s :(
     ;; (use-package gitlab)
     ;; (use-package ivy-gitlab :after gitlab)
   #+END_SRC

** Git Config

   Mode for editing git config files:
   #+BEGIN_SRC emacs-lisp
     (use-package gitconfig-mode :defer t)
   #+END_SRC

** Git Ignore

   Manage ~.gitignore~ file:
   #+BEGIN_SRC emacs-lisp
     (use-package gitignore-mode :defer t)
   #+END_SRC

** Git Attributes

   Mode for editing git attributes:
   #+BEGIN_SRC emacs-lisp
     (use-package gitattributes-mode :defer t)
   #+END_SRC

** Git Time Machine

   Helps to move forward and backward buffer in git history:
   #+BEGIN_SRC emacs-lisp
      (use-package git-timemachine
	:commands git-timemachine)
   #+END_SRC

** Highlight VC

   Highlight uncommitted changes using VC.

   Provided commands:

   | Command                  | Keyboard  |
   |--------------------------+-----------|
   | ~diff-hl-diff-goto-hunk~ | ~C-x v =~ |
   | ~diff-hl-revert-hunk~    | ~C-x v n~ |
   | ~diff-hl-previous-hunk~  | ~C-x v [~ |
   | ~diff-hl-next-hunk~      | ~C-x v ]~ |

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :hook ((prog-mode org-mode) . diff-hl-mode))

     (use-package diff-hl-dired
       :ensure diff-hl
       :hook (dired-mode . diff-hl-dired-mode))
   #+END_SRC

* WORK IS IN PROGRESS NOW

  This part of confiuration *is not* tangled so not applied.

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package format-all
      :commands format-all-buffer)

    (use-package cmake-mode :defer t)

    ;; HTML
    (use-package emmet-mode
      :hook ((html-mode css-mode) . emmet-mode))
    ;;----------------------------------------------------------------------------
    ;; Poly Mode
    ;;----------------------------------------------------------------------------
    (require 'init-polymode)

    (use-package diff-mode :ensure nil)
    (use-package diffview :ensure nil
      :commands (diffview-current diffview-region diffview-message))

    ;; Dealing with huge files
    (use-package vlf
      :commands (vlf))

    ;; TODO: use-internal-package vc

    (use-package nginx-mode :defer t)


    (use-package sass-mode :defer t)

    ;; Colorize color names in buffers
    (use-package rainbow-mode
      :hook (css-mode html-mode sass-mode))

    (use-package anaconda-mode
      :hook ((python-mode . anaconda-mode)
         (python-mode . anaconda-eldoc-mode)))

    ;; TODO: fix better loading
    (use-package company-anaconda :defer t
      :config
      (add-to-list 'company-backends 'company-anaconda))

    (use-package pip-requirements :defer t)


    
    ;; Ruby

    (use-package rspec-mode :defer t)
    (use-package robe :defer t)
    (use-package yari :defer t)
    (use-package bundler :defer t)
    (use-package yard-mode :defer t :diminish)
    (use-package rvm :defer t)

    

    
    ;; Ispell
    ;; TODO: flyspell, magit-status
    (use-package ispell :ensure nil :defer t)
    (use-package flyspell-correct-ivy
      :commands flyspell-correct-wrapper
      :init
      (setq flyspell-correct-interface #'flyspell-correct-ivy))

    
    ;; GO Language
    ;; TODO: unconfigured yet
    (use-package go-mode :defer t)
    (use-package go-guru :defer t)
    (use-package company-go :defer t)
    (use-package golint :defer t)


    ;; TODO: May be useful
    (use-package sgml-mode
      :ensure nil
      :delight html-mode "HTML"
      :preface
      (defun me/html-set-pretty-print-function ()
    (setq me/pretty-print-function #'sgml-pretty-print))
      :hook
      ((html-mode . me/html-set-pretty-print-function)
       (html-mode . sgml-electric-tag-pair-mode)
       (html-mode . sgml-name-8bit-mode)
       (html-mode . toggle-truncate-lines))
      :config (setq-default sgml-basic-offset 2))
  #+END_SRC
